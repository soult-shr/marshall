<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Rocket Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a30;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
        }
        #gameCanvas {
            border: 2px solid #334;
            border-radius: 4px;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
        }
        #fuelBar {
            width: 150px;
            height: 16px;
            background: #223;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
            border: 1px solid #445;
        }
        #fuelLevel {
            height: 100%;
            background: #4a4;
            transition: width 0.1s;
        }
        #score {
            margin-top: 10px;
            font-size: 18px;
            color: #ffcc00;
        }
        #kills {
            margin-top: 5px;
            font-size: 14px;
            color: #ff6666;
        }
        #options {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 13px;
        }
        .option {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            user-select: none;
        }
        .option:hover {
            color: #aaf;
        }
        .checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid #556;
            border-radius: 3px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #223;
        }
        .checkbox.checked {
            background: #4a4;
            border-color: #6c6;
        }
        .checkbox.checked::after {
            content: '✓';
            color: #fff;
            font-size: 12px;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #667;
            font-size: 12px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 28px;
            text-align: center;
            display: none;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 8px;
        }
        #gameOver button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            background: #4466aa;
            color: #fff;
            border: none;
            border-radius: 4px;
        }
        #gameOver button:hover {
            background: #5577bb;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>FUEL</div>
            <div id="fuelBar"><div id="fuelLevel"></div></div>
            <div id="score">Score: 0</div>
            <div id="kills">Kills: 0</div>
        </div>
        <div id="options">
            <div class="option" onclick="toggleUnlimitedFuel()">
                <div class="checkbox" id="unlimitedFuelCheck"></div>
                <span>Unlimited Fuel</span>
            </div>
            <div class="option" onclick="toggleImmortality()">
                <div class="checkbox" id="immortalityCheck"></div>
                <span>Immortality</span>
            </div>
        </div>
        <div id="instructions">
            [↑] Up | [↓] Down | [←] Left | [→] Right | [SPACE] Shoot
        </div>
        <div id="gameOver">
            <div id="gameOverText">GAME OVER</div>
            <div id="finalScore"></div>
            <button onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1000;
        canvas.height = 500;
        
        // Game constants
        const GRAVITY = 0.05;
        const THRUST = 0.3;
        const FUEL_CONSUMPTION = 0.3;
        const MAX_FUEL = 100;
        const FRICTION = 0.98;
        const BULLET_SPEED = 12;
        const ASTEROID_SPAWN_RATE = 60;
        
        // Options
        let unlimitedFuel = false;
        let immortality = false;
        
        // Game state
        let gameOver = false;
        let maxDistance = 0;
        let kills = 0;
        let frameCount = 0;
        
        // Camera
        let cameraX = 0;
        
        // Rocket state
        let rocket = {
            x: 200,
            y: 250,
            vx: 0,
            vy: 0,
            fuel: MAX_FUEL,
            radius: 12
        };
        
        // Bullets
        let bullets = [];
        
        // Asteroids
        let asteroids = [];
        
        // Explosions
        let explosions = [];
        
        // Input state
        const keys = {};
        let canShoot = true;
        
        // Stars (parallax layers)
        const stars = [];
        for (let i = 0; i < 200; i++) {
            stars.push({
                x: Math.random() * 3000,
                y: Math.random() * canvas.height,
                size: Math.random() * 1.5 + 0.5,
                depth: Math.random() * 0.5 + 0.1
            });
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'Space') canShoot = true;
        });
        
        // Option toggles
        function toggleUnlimitedFuel() {
            unlimitedFuel = !unlimitedFuel;
            document.getElementById('unlimitedFuelCheck').classList.toggle('checked', unlimitedFuel);
            if (unlimitedFuel) {
                rocket.fuel = MAX_FUEL;
            }
        }
        
        function toggleImmortality() {
            immortality = !immortality;
            document.getElementById('immortalityCheck').classList.toggle('checked', immortality);
        }
        
        function spawnAsteroid() {
            const size = 15 + Math.random() * 30;
            const y = Math.random() * canvas.height;
            const speed = 2 + Math.random() * 3;
            
            asteroids.push({
                x: rocket.x + canvas.width + 100,
                y: y,
                vx: -speed - rocket.vx * 0.3,
                vy: (Math.random() - 0.5) * 2,
                radius: size,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.1,
                vertices: generateAsteroidShape(size)
            });
        }
        
        function generateAsteroidShape(radius) {
            const vertices = [];
            const numVertices = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numVertices; i++) {
                const angle = (i / numVertices) * Math.PI * 2;
                const r = radius * (0.7 + Math.random() * 0.3);
                vertices.push({ angle, r });
            }
            return vertices;
        }
        
        function createExplosion(x, y, size) {
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                explosions.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 2 + Math.random() * 3,
                    life: 30 + Math.random() * 20,
                    color: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`
                });
            }
        }
        
        function shoot() {
            if (!canShoot) return;
            canShoot = false;
            
            bullets.push({
                x: rocket.x + rocket.radius + 5,
                y: rocket.y,
                vx: BULLET_SPEED,
                vy: 0,
                radius: 4
            });
        }
        
        function drawStars() {
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                const screenX = (star.x - cameraX * star.depth) % (canvas.width + 500);
                const adjustedX = screenX < 0 ? screenX + canvas.width + 500 : screenX;
                ctx.beginPath();
                ctx.arc(adjustedX, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawRocket() {
            const screenX = rocket.x - cameraX;
            
            ctx.save();
            ctx.translate(screenX, rocket.y);
            
            // Draw flame when thrusting
            const thrusting = (rocket.fuel > 0 || unlimitedFuel) && (keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']);
            
            if (thrusting) {
                ctx.fillStyle = '#ff6600';
                const flameSize = 8 + Math.random() * 5;
                
                if (keys['ArrowUp']) {
                    ctx.beginPath();
                    ctx.moveTo(-5, rocket.radius);
                    ctx.lineTo(5, rocket.radius);
                    ctx.lineTo(0, rocket.radius + flameSize);
                    ctx.closePath();
                    ctx.fill();
                }
                if (keys['ArrowDown']) {
                    ctx.beginPath();
                    ctx.moveTo(-5, -rocket.radius);
                    ctx.lineTo(5, -rocket.radius);
                    ctx.lineTo(0, -rocket.radius - flameSize);
                    ctx.closePath();
                    ctx.fill();
                }
                if (keys['ArrowLeft']) {
                    ctx.beginPath();
                    ctx.moveTo(rocket.radius, -5);
                    ctx.lineTo(rocket.radius, 5);
                    ctx.lineTo(rocket.radius + flameSize, 0);
                    ctx.closePath();
                    ctx.fill();
                }
                if (keys['ArrowRight']) {
                    ctx.beginPath();
                    ctx.moveTo(-rocket.radius, -5);
                    ctx.lineTo(-rocket.radius, 5);
                    ctx.lineTo(-rocket.radius - flameSize, 0);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Immortality glow
            if (immortality) {
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
            }
            
            // Rocket body (white circle)
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, 0, rocket.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Weapon indicator (small triangle on right side)
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(rocket.radius + 2, -4);
            ctx.lineTo(rocket.radius + 8, 0);
            ctx.lineTo(rocket.radius + 2, 4);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawBullets() {
            ctx.fillStyle = '#ffff00';
            bullets.forEach(bullet => {
                const screenX = bullet.x - cameraX;
                ctx.beginPath();
                ctx.arc(screenX, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawAsteroids() {
            asteroids.forEach(asteroid => {
                const screenX = asteroid.x - cameraX;
                
                if (screenX < -100 || screenX > canvas.width + 100) return;
                
                ctx.save();
                ctx.translate(screenX, asteroid.y);
                ctx.rotate(asteroid.rotation);
                
                ctx.fillStyle = '#666655';
                ctx.strokeStyle = '#888877';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                asteroid.vertices.forEach((v, i) => {
                    const x = Math.cos(v.angle) * v.r;
                    const y = Math.sin(v.angle) * v.r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            });
        }
        
        function drawExplosions() {
            explosions.forEach(p => {
                const screenX = p.x - cameraX;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 50;
                ctx.beginPath();
                ctx.arc(screenX, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
        
        function checkCollisions() {
            // Bullets vs Asteroids
            bullets.forEach((bullet, bi) => {
                asteroids.forEach((asteroid, ai) => {
                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < bullet.radius + asteroid.radius) {
                        createExplosion(asteroid.x, asteroid.y, asteroid.radius);
                        bullets.splice(bi, 1);
                        asteroids.splice(ai, 1);
                        kills++;
                    }
                });
            });
            
            // Rocket vs Asteroids
            if (!immortality) {
                asteroids.forEach(asteroid => {
                    const dx = rocket.x - asteroid.x;
                    const dy = rocket.y - asteroid.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < rocket.radius + asteroid.radius) {
                        endGame();
                    }
                });
            }
        }
        
        function endGame() {
            gameOver = true;
            document.getElementById('finalScore').textContent = `Score: ${Math.floor(maxDistance)} | Kills: ${kills}`;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            rocket = {
                x: 200,
                y: 250,
                vx: 0,
                vy: 0,
                fuel: MAX_FUEL,
                radius: 12
            };
            bullets = [];
            asteroids = [];
            explosions = [];
            maxDistance = 0;
            kills = 0;
            cameraX = 0;
            gameOver = false;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function update() {
            if (gameOver) return;
            
            frameCount++;
            
            // Thrust controls
            if (keys['ArrowUp'] && (rocket.fuel > 0 || unlimitedFuel)) {
                rocket.vy -= THRUST;
                if (!unlimitedFuel) rocket.fuel -= FUEL_CONSUMPTION;
            }
            if (keys['ArrowDown'] && (rocket.fuel > 0 || unlimitedFuel)) {
                rocket.vy += THRUST * 0.5;
                if (!unlimitedFuel) rocket.fuel -= FUEL_CONSUMPTION;
            }
            if (keys['ArrowLeft'] && (rocket.fuel > 0 || unlimitedFuel)) {
                rocket.vx -= THRUST;
                if (!unlimitedFuel) rocket.fuel -= FUEL_CONSUMPTION;
            }
            if (keys['ArrowRight'] && (rocket.fuel > 0 || unlimitedFuel)) {
                rocket.vx += THRUST;
                if (!unlimitedFuel) rocket.fuel -= FUEL_CONSUMPTION;
            }
            
            // Shooting
            if (keys['Space']) {
                shoot();
            }
            
            rocket.fuel = Math.max(0, rocket.fuel);
            
            // Gravity (slight)
            rocket.vy += GRAVITY;
            
            // Friction
            rocket.vx *= FRICTION;
            rocket.vy *= FRICTION;
            
            // Update position
            rocket.x += rocket.vx;
            rocket.y += rocket.vy;
            
            // Boundaries
            if (rocket.y < rocket.radius) {
                rocket.y = rocket.radius;
                rocket.vy = 0;
            }
            if (rocket.y > canvas.height - rocket.radius) {
                rocket.y = canvas.height - rocket.radius;
                rocket.vy = 0;
            }
            if (rocket.x < rocket.radius) {
                rocket.x = rocket.radius;
                rocket.vx = 0;
            }
            
            // Update score
            if (rocket.x > maxDistance) {
                maxDistance = rocket.x;
            }
            
            // Update camera
            const targetCameraX = rocket.x - canvas.width / 3;
            cameraX = Math.max(0, targetCameraX);
            
            // Spawn asteroids
            if (frameCount % ASTEROID_SPAWN_RATE === 0) {
                spawnAsteroid();
            }
            
            // Update bullets
            bullets.forEach((bullet, i) => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Remove off-screen bullets
                if (bullet.x - cameraX > canvas.width + 50) {
                    bullets.splice(i, 1);
                }
            });
            
            // Update asteroids
            asteroids.forEach((asteroid, i) => {
                asteroid.x += asteroid.vx;
                asteroid.y += asteroid.vy;
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Bounce off top/bottom
                if (asteroid.y < asteroid.radius || asteroid.y > canvas.height - asteroid.radius) {
                    asteroid.vy *= -1;
                }
                
                // Remove off-screen asteroids
                if (asteroid.x < cameraX - 200) {
                    asteroids.splice(i, 1);
                }
            });
            
            // Update explosions
            explosions.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) {
                    explosions.splice(i, 1);
                }
            });
            
            // Check collisions
            checkCollisions();
            
            // Update UI
            const fuelPercent = unlimitedFuel ? 100 : (rocket.fuel / MAX_FUEL * 100);
            document.getElementById('fuelLevel').style.width = fuelPercent + '%';
            document.getElementById('score').textContent = 'Score: ' + Math.floor(maxDistance);
            document.getElementById('kills').textContent = 'Kills: ' + kills;
        }
        
        function draw() {
            // Background
            ctx.fillStyle = '#0a0a30';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars
            drawStars();
            
            // Explosions
            drawExplosions();
            
            // Asteroids
            drawAsteroids();
            
            // Bullets
            drawBullets();
            
            // Rocket
            drawRocket();
            
            // Fuel warning
            if (!unlimitedFuel) {
                if (rocket.fuel < 20 && rocket.fuel > 0) {
                    ctx.fillStyle = '#ff4444';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('LOW FUEL', canvas.width / 2, 40);
                } else if (rocket.fuel === 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('NO FUEL', canvas.width / 2, 40);
                }
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>
